import { App, Notice } from 'obsidian';
import { DateNavigator } from './DateNavigator';
import { TimeFilterManager, DateRange } from '../../timeFilters';
import { DreamMetricsState } from '../../state/DreamMetricsState';
import { format } from 'date-fns';
import { getService, registerService, SERVICE_NAMES } from '../../state/ServiceRegistry';
import { error, info, debug, warn } from '../../logging';

// Import web worker manager for Phase 2 integration
import { DateNavigatorWorkerManager } from '../../workers/DateNavigatorWorkerManager';
import safeLogger from '../../logging/safe-logger';

// Safely reference global logger without causing errors if it's not defined
declare global {
    interface Window {
        globalLogger?: any;
    }
}

export class DateNavigatorIntegration {
    private app: App;
    private state: DreamMetricsState;
    private timeFilterManager: TimeFilterManager;
    public dateNavigator: DateNavigator | null = null;
    private container: HTMLElement | null = null;
    private isUpdatingSelection: boolean = false; // Add a flag to prevent recursive updates
    private rangeSelectionMode: boolean = false;
    private rangeStartDate: Date | null = null;
    private rangeEndDate: Date | null = null;
    private completedRange: { start: Date; end: Date } | null = null;
    
    // Phase 2: Web Worker Integration
    private workerManager: DateNavigatorWorkerManager;
    private progressIndicator: HTMLElement | null = null;
    private isProcessing: boolean = false;
    
    constructor(app: App, state: DreamMetricsState | any, filterManager?: TimeFilterManager) {
        this.app = app;
        
        // Handle the case where the second parameter is actually the plugin
        if (state && !(state instanceof DreamMetricsState) && typeof state === 'object') {
            // Extract state and filter manager from plugin
            this.state = state.state || new DreamMetricsState();
            // Use the provided filter manager, or try to get from plugin, or from service registry
            this.timeFilterManager = filterManager || state.timeFilterManager || getService<TimeFilterManager>(SERVICE_NAMES.TIME_FILTER);
        } else {
            // Normal case - state is provided directly
            this.state = state;
            // Use the provided filter manager or try to get from service registry
            this.timeFilterManager = filterManager || getService<TimeFilterManager>(SERVICE_NAMES.TIME_FILTER);
        }
        
        // Phase 2: Initialize Web Worker Manager
        try {
            this.workerManager = new DateNavigatorWorkerManager(this.app);
            safeLogger.info('DateNavigatorIntegration', 'Web worker manager initialized successfully');
        } catch (error) {
            safeLogger.error('DateNavigatorIntegration', 'Failed to initialize web worker manager, will use fallback processing', 
                error instanceof Error ? error : new Error(String(error)));
            // Continue without worker - fallback will be used automatically
        }
        
        // If still no TimeFilterManager, create and register a new one
        if (!this.timeFilterManager) {
            try {
                if (window.globalLogger) {
                    window.globalLogger.info('DateNavigatorIntegration', 'Creating new TimeFilterManager');
                } else {
                    info('DateNavigatorIntegration', 'Creating new TimeFilterManager');
                }
                
                // Create a new TimeFilterManager
                this.timeFilterManager = new TimeFilterManager();
                
                // Register the new TimeFilterManager with the service registry
                try {
                    registerService(SERVICE_NAMES.TIME_FILTER, this.timeFilterManager);
                    info('DateNavigatorIntegration', 'Registered new TimeFilterManager with service registry');
                } catch (e) {
                    error('DateNavigatorIntegration', 'Error registering TimeFilterManager with service registry', e);
                }
            } catch (e) {
                error('DateNavigatorIntegration', 'Error creating TimeFilterManager', e);
            }
        }
        
        // Final check to ensure timeFilterManager is properly initialized
        if (!this.timeFilterManager) {
            error('DateNavigatorIntegration', 'Failed to initialize TimeFilterManager');
            // Create a minimal implementation to prevent errors
            this.timeFilterManager = {
                onFilterChange: () => {},
                getCurrentRange: () => null
            } as unknown as TimeFilterManager; // Use double assertion to bypass type checking
        }
        
        // Set up filter change handler if possible
        if (this.timeFilterManager && typeof this.timeFilterManager.onFilterChange !== 'undefined') {
            try {
                // Define the filter change handler function
                const filterChangeHandler = (filter: any) => {
                    if (filter && typeof filter.getDateRange === 'function') {
                        this.handleFilterChange(filter.getDateRange());
                    } else {
                        warn('DateNavigatorIntegration', 'Filter object is invalid or missing getDateRange method');
                    }
                };
                
                // Safely assign the handler
                this.timeFilterManager.onFilterChange = filterChangeHandler;
                info('DateNavigatorIntegration', 'Successfully set up filter change handler');
            } catch (e) {
                error('DateNavigatorIntegration', 'Error setting up filter change handler', e);
            }
        } else {
            warn('DateNavigatorIntegration', 'Unable to set up filter change handler - timeFilterManager.onFilterChange is not a function');
        }
    }
    
    /**
     * Initialize the Date Navigator in the specified container
     */
    public initialize(container: HTMLElement): DateNavigator {
        this.container = container;
        
        // Create the date navigator
        this.dateNavigator = new DateNavigator(container, this.state);
        
        // Apply any active filter
        try {
            if (this.timeFilterManager && typeof this.timeFilterManager.getCurrentRange === 'function') {
                const currentRange = this.timeFilterManager.getCurrentRange();
                if (currentRange) {
                    this.handleFilterChange(currentRange);
                }
            }
        } catch (e) {
            // Safely log the error
            try {
                if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                    window['globalLogger'].error('DateNavigatorIntegration: Error applying current filter range', e);
                }
            } catch (err) {
                // Silent failure
            }
        }
        
        // Set up selection handler
        this.setupSelectionHandler();

        // Add a range selection toggle button
        this.addRangeSelectionToggle();
        
        // Check if we need to populate entries from plugin
        this.checkAndPopulateEntries();
        
        // Make debug function globally accessible
        try {
            // Add a global function to trigger debug display
            window['debugDateNavigator'] = () => {
                if (this.dateNavigator && typeof this.dateNavigator.debugDisplay === 'function') {
                    this.dateNavigator.debugDisplay();
                } else {
                    error('DateNavigatorIntegration', 'DateNavigator debugDisplay function not available');
                }
            };
        } catch (e) {
            error('DateNavigatorIntegration', 'Error setting up global debug function', e);
        }
        
        return this.dateNavigator;
    }
    
    /**
     * Check if state has entries, and if not, try to get them from plugin
     */
    private checkAndPopulateEntries(): void {
        try {
            if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                window['globalLogger'].debug('DateNavigatorIntegration', 'Starting entries check');
                window['globalLogger'].debug('DateNavigatorIntegration', 'Checking for entries in state');
            }
            
            // First check if state already has entries
            const stateEntries = this.state?.getDreamEntries?.() || [];
            if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                window['globalLogger'].debug('DateNavigatorIntegration', `State has ${stateEntries.length} entries`);
            }
            
            if (stateEntries && stateEntries.length > 0) {
                if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                    window['globalLogger'].debug('DateNavigatorIntegration', `State already has ${stateEntries.length} entries`);
                }
                
                // Even if state has entries, let's also try to make sure the DateNavigator has them
                if (this.dateNavigator && stateEntries.length > 0) {
                    if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                        window['globalLogger'].debug('DateNavigatorIntegration', `Explicitly setting ${stateEntries.length} entries from state to DateNavigator`);
                    }
                    this.dateNavigator.setDreamEntries(stateEntries);
                }
                
                return; // State already has entries
            }
            
            // If we're here, we need to check for entries in other places
            if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                window['globalLogger'].debug('DateNavigatorIntegration', 'No entries in state, checking for alternative sources');
                window['globalLogger'].debug('DateNavigatorIntegration', 'No entries in state, checking plugin');
            }
            
            // Try to get entries from window.oneiroMetricsPlugin
            if (window['oneiroMetricsPlugin']) {
                if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                    window['globalLogger'].debug('DateNavigatorIntegration', 'Found window.oneiroMetricsPlugin, checking for entries');
                }
                
                // Use 'any' type to bypass type checking for the global plugin
                const globalPlugin = window['oneiroMetricsPlugin'] as any;
                
                // Try to get entries from the global plugin instance
                let globalEntries = null;
                
                if (globalPlugin.state && typeof globalPlugin.state.getDreamEntries === 'function') {
                    globalEntries = globalPlugin.state.getDreamEntries();
                    if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                        window['globalLogger'].debug('DateNavigatorIntegration', `Found ${globalEntries?.length || 0} entries from global plugin state`);
                    }
                } else if (globalPlugin.entries && Array.isArray(globalPlugin.entries)) {
                    // Using any type to bypass type checking
                    globalEntries = globalPlugin.entries;
                    if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                        window['globalLogger'].debug('DateNavigatorIntegration', `Found ${globalEntries.length} entries from global plugin entries`);
                    }
                }
                
                if (globalEntries && globalEntries.length > 0) {
                    if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                        window['globalLogger'].debug('DateNavigatorIntegration', `Using ${globalEntries.length} entries from global plugin`);
                    }
                    
                    // Update DateNavigator with entries
                    if (this.dateNavigator) {
                        this.dateNavigator.setDreamEntries(globalEntries);
                        if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                            window['globalLogger'].debug('DateNavigatorIntegration', 'Updated entries using global plugin entries');
                        }
                    }
                    
                    return; // Successfully used global plugin entries
                }
            }
            
            // If state was passed as part of plugin, try to get entries from plugin
            if (this.state && !(this.state instanceof DreamMetricsState) && typeof this.state === 'object') {
                // Cast to any to access potential plugin properties
                const plugin: any = this.state;
                
                if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                    window['globalLogger'].debug('DateNavigatorIntegration', 'State might be plugin, checking its properties');
                }
                
                // Try to get entries directly
                let entries = null;
                
                // Dump available properties for debugging
                if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                    window['globalLogger'].debug('DateNavigatorIntegration', 'Plugin properties:', Object.keys(plugin));
                    if (plugin.state) {
                        window['globalLogger'].debug('DateNavigatorIntegration', 'Plugin state properties:', Object.keys(plugin.state));
                    }
                }
                
                // Try different potential sources of entries
                if (plugin.entries && Array.isArray(plugin.entries) && plugin.entries.length > 0) {
                    entries = plugin.entries;
                    if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                        window['globalLogger'].debug('DateNavigatorIntegration', `Found ${entries.length} entries in plugin.entries`);
                    }
                } else if (plugin.state && plugin.state.entries && Array.isArray(plugin.state.entries)) {
                    entries = plugin.state.entries;
                    if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                        window['globalLogger'].debug('DateNavigatorIntegration', `Found ${entries.length} entries in plugin.state.entries`);
                    }
                } else if (plugin.state && typeof plugin.state.getDreamEntries === 'function') {
                    entries = plugin.state.getDreamEntries();
                    if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                        window['globalLogger'].debug('DateNavigatorIntegration', `Found ${entries?.length || 0} entries from plugin.state.getDreamEntries()`);
                    }
                } else if (plugin.dreamEntries && Array.isArray(plugin.dreamEntries)) {
                    entries = plugin.dreamEntries;
                    if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                        window['globalLogger'].debug('DateNavigatorIntegration', `Found ${entries.length} entries in plugin.dreamEntries`);
                    }
                }
                
                // FALLBACK: Try to extract entries from any tables in the UI
                if ((!entries || entries.length === 0) && typeof document !== 'undefined') {
                    if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                        window['globalLogger'].debug('DateNavigatorIntegration', 'No entries found through API, trying to extract from UI tables');
                    }
                    
                    try {
                        const dreamRows = document.querySelectorAll('.oom-dream-row');
                        if (dreamRows && dreamRows.length > 0) {
                            if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                                window['globalLogger'].debug('DateNavigatorIntegration', `Found ${dreamRows.length} dream rows in tables`);
                            }
                            
                            // Extract entries from rows
                            const tableEntries = [];
                            dreamRows.forEach((row, idx) => {
                                try {
                                    const dateCell = row.querySelector('td:first-child');
                                    const titleCell = row.querySelector('td:nth-child(2)');
                                    
                                    if (dateCell && titleCell) {
                                        const dateText = dateCell.textContent?.trim();
                                        const titleText = titleCell.textContent?.trim();
                                        
                                        if (dateText) {
                                            tableEntries.push({
                                                date: dateText,
                                                title: titleText || 'Unknown title',
                                                content: titleText || 'Unknown content',
                                                source: 'table-extraction',
                                                metrics: {}
                                            });
                                        }
                                    }
                                } catch (rowErr) {
                                    if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                                        window['globalLogger'].error('DateNavigatorIntegration', `Error extracting entry from row ${idx}:`, rowErr);
                                    }
                                }
                            });
                            
                            if (tableEntries.length > 0) {
                                if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                                    window['globalLogger'].debug('DateNavigatorIntegration', `Extracted ${tableEntries.length} entries from UI tables`);
                                }
                                entries = tableEntries;
                            }
                        }
                    } catch (tableErr) {
                        if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                            window['globalLogger'].error('DateNavigatorIntegration', 'Error extracting entries from tables:', tableErr);
                        }
                    }
                }
                
                // If we found entries, update the state
                if (entries && entries.length > 0) {
                    if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                        window['globalLogger'].debug('DateNavigatorIntegration', `Updating state with ${entries.length} entries`);
                        // Sample the first entry for debugging
                        window['globalLogger'].debug('DateNavigatorIntegration', 'First entry sample:', entries[0]);
                    }
                    
                    // Use the new setDreamEntries method if available
                    if (this.dateNavigator) {
                        this.dateNavigator.setDreamEntries(entries);
                        if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                            window['globalLogger'].debug('DateNavigatorIntegration', 'Updated entries using dateNavigator.setDreamEntries()');
                        }
                    }
                    // If no DateNavigator but state has updateDreamEntries method, use it
                    else if (this.state && typeof (this.state as any).updateDreamEntries === 'function') {
                        (this.state as any).updateDreamEntries(entries);
                        if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                            window['globalLogger'].debug('DateNavigatorIntegration', 'Updated entries using state.updateDreamEntries()');
                        }
                    }
                } else {
                    if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                        window['globalLogger'].warn('DateNavigatorIntegration', 'Could not find any entries in plugin object');
                    }
                }
            }
        } catch (e) {
            if (typeof window['globalLogger'] !== 'undefined' && window['globalLogger']) {
                window['globalLogger'].error('DateNavigatorIntegration', 'Error checking for entries', e);
            }
        }
    }
    
    /**
     * Add a toggle button for range selection mode
     */
    private addRangeSelectionToggle(): void {
        if (!this.container) {
            safeLogger.warn('DateNavigatorIntegration', 'Cannot add range selection toggle - no container');
            return;
        }
        
        safeLogger.debug('DateNavigatorIntegration', 'Adding range selection toggle to container');
        
        // Create button container
        const buttonContainer = this.container.createDiv('oom-date-navigator-controls');
        buttonContainer.style.cssText = `
            padding: 10px 0;
            border-top: 1px solid var(--background-modifier-border);
            margin-top: 10px;
        `;
        
        // Create range selection toggle button
        const rangeToggleBtn = buttonContainer.createEl('button', {
            cls: 'oom-range-selection-toggle',
            text: 'Range Selection: Off',
            attr: {
                'aria-pressed': 'false',
                'title': 'Toggle range selection mode'
            }
        });
        
        // Add explicit styling to make it visible
        rangeToggleBtn.style.cssText = `
            background: var(--interactive-normal);
            color: var(--text-normal);
            border: 1px solid var(--background-modifier-border);
            border-radius: 4px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px 0;
        `;
        
        safeLogger.info('DateNavigatorIntegration', 'Range selection toggle button created and styled');
        
        // Add click event listener
        rangeToggleBtn.addEventListener('click', () => {
            this.rangeSelectionMode = !this.rangeSelectionMode;
            
            safeLogger.info('DateNavigatorIntegration', 'Range selection mode toggled', { 
                rangeSelectionMode: this.rangeSelectionMode 
            });
            
            // Update button text and aria state
            rangeToggleBtn.textContent = `Range Selection: ${this.rangeSelectionMode ? 'On' : 'Off'}`;
            rangeToggleBtn.setAttribute('aria-pressed', this.rangeSelectionMode ? 'true' : 'false');
            
            // Toggle active class for styling
            if (this.rangeSelectionMode) {
                rangeToggleBtn.classList.add('oom-range-active');
                rangeToggleBtn.style.background = 'var(--interactive-accent)';
                rangeToggleBtn.style.color = 'var(--text-on-accent)';
                
                // IMPROVED UX: If there's already a selected date, use it as range start
                if (this.dateNavigator && this.dateNavigator.getSelectedDay()) {
                    this.rangeStartDate = new Date(this.dateNavigator.getSelectedDay());
                    safeLogger.info('DateNavigatorIntegration', 'Using currently selected date as range start', {
                        rangeStartDate: this.rangeStartDate.toISOString().split('T')[0]
                    });
                    new Notice(`ðŸŽ¯ Range Mode ON: Start date set to ${this.rangeStartDate.toLocaleDateString()}. Now select end date.`, 4000);
                } else {
                    // Reset range selection for fresh start
                    this.rangeStartDate = null;
                    this.rangeEndDate = null;
                    new Notice('ðŸŽ¯ Range Selection Mode ON: Select start date then end date to filter a range', 4000);
                }
                
                safeLogger.info('DateNavigatorIntegration', 'Range selection mode enabled - button styled active');
            } else {
                rangeToggleBtn.classList.remove('oom-range-active');
                rangeToggleBtn.style.background = 'var(--interactive-normal)';
                rangeToggleBtn.style.color = 'var(--text-normal)';
                
                // Clear any in-progress range selection
                if (this.rangeStartDate && !this.rangeEndDate) {
                    this.rangeStartDate = null;
                    
                    // Update UI to clear any selection markers
                    if (this.dateNavigator) {
                        this.dateNavigator.clearSelection();
                    }
                }
                
                // Reset both range dates when turning off
                this.rangeStartDate = null;
                this.rangeEndDate = null;
                this.completedRange = null;
                
                // Clear visual range highlights
                this.clearRangeHighlights();
                
                new Notice('Range Selection Mode OFF', 2000);
                safeLogger.info('DateNavigatorIntegration', 'Range selection mode disabled - button styled normal');
            }
        });
    }
    
    /**
     * Setup the selection handler to connect day selection with the filter system
     */
    private setupSelectionHandler(): void {
        if (!this.dateNavigator) return;
        
        // Override the applyFilter method of the DateNavigator
        const originalApplyFilter = this.dateNavigator.applyFilter;
        this.dateNavigator.applyFilter = async (startDate: Date | null, endDate: Date | null) => {
            // Priority 1: Handle range selection mode for individual date clicks
            if (this.rangeSelectionMode && !this.completedRange) {
                // We're in range selection mode but don't have a completed range yet
                // This means we're selecting individual dates for the range
                this.handleRangeSelection(startDate);
                return;
            }
            
            // Priority 2: Check if we have a completed range that should be applied
            // This happens when Apply Filter is clicked after completing a range selection
            if (this.completedRange) {
                safeLogger.info('DateNavigatorIntegration', 'Applying completed range selection', {
                    startDate: this.completedRange.start.toISOString().split('T')[0],
                    endDate: this.completedRange.end.toISOString().split('T')[0],
                    rangeSelectionMode: this.rangeSelectionMode,
                    startDateFull: this.completedRange.start.toISOString(),
                    endDateFull: this.completedRange.end.toISOString(),
                    startTime: this.completedRange.start.getTime(),
                    endTime: this.completedRange.end.getTime(),
                    receivedStartDate: startDate?.toISOString?.() || startDate,
                    receivedEndDate: endDate?.toISOString?.() || endDate
                });
                
                // CRITICAL FIX: Temporarily disable the global forceApplyDateFilter to prevent conflicts
                const originalForceApplyDateFilter = (window as any).forceApplyDateFilter;
                (window as any).forceApplyDateFilter = () => {
                    safeLogger.info('DateNavigatorIntegration', 'Blocked conflicting forceApplyDateFilter call during range processing');
                };
                
                // Apply the range filter
                await this.applyDateFilter(this.completedRange.start, this.completedRange.end);
                
                // Restore the original function after a delay to ensure our processing completes
                setTimeout(() => {
                    (window as any).forceApplyDateFilter = originalForceApplyDateFilter;
                    safeLogger.info('DateNavigatorIntegration', 'Restored original forceApplyDateFilter function');
                }, 1000);
                
                // Reset range selection state
                this.rangeStartDate = null;
                this.rangeEndDate = null;
                this.completedRange = null;
                this.rangeSelectionMode = false;
                
                // Update toggle button
                const rangeToggleBtn = this.container?.querySelector('.oom-range-selection-toggle');
                if (rangeToggleBtn) {
                    rangeToggleBtn.textContent = 'Range Selection: Off';
                    rangeToggleBtn.setAttribute('aria-pressed', 'false');
                    (rangeToggleBtn as HTMLElement).classList.remove('oom-range-active');
                    (rangeToggleBtn as HTMLElement).style.background = 'var(--interactive-normal)';
                    (rangeToggleBtn as HTMLElement).style.color = 'var(--text-normal)';
                }
                
                // Clear range highlights after successful application
                this.clearRangeHighlights();
                
                return;
            }
            
            // Priority 3: For standard mode (not range selection), call the original method first
            originalApplyFilter.call(this.dateNavigator, startDate, endDate);
            
            // Then handle the filter change with worker enhancement
            if (startDate && endDate) {
                await this.applyDateFilter(startDate, endDate);
            } else {
                await this.clearDateFilter();
            }
        };
    }
    
    /**
     * Phase 2: Worker-enhanced date filter application
     */
    private async applyDateFilter(startDate: Date, endDate: Date): Promise<void> {
        // Prevent recursive updates
        if (this.isUpdatingSelection || this.isProcessing) return;
        
        safeLogger.info('DateNavigatorIntegration', 'applyDateFilter called with', {
            startDate: startDate.toISOString().split('T')[0],
            endDate: endDate.toISOString().split('T')[0],
            startDateFull: startDate.toISOString(),
            endDateFull: endDate.toISOString(),
            startTime: startDate.getTime(),
            endTime: endDate.getTime(),
            isSameDay: this.isSameDay(startDate, endDate),
            daysDifference: Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24))
        });
        
        this.isUpdatingSelection = true;
        this.isProcessing = true;
        
        try {
            // Show progress indicator during processing
            // this.showProgressIndicator('Applying date filter...');
            new Notice('ðŸš€ Applying date filter...', 3000);
            
            try {
                safeLogger.info('DateNavigatorIntegration', 'Using web worker for date filtering', {
                    rangeStart: startDate.toISOString().split('T')[0],
                    rangeEnd: endDate.toISOString().split('T')[0]
                });
                
                // Get entries from state for processing
                const stateEntries = this.state?.getDreamEntries?.() || [];
                
                const result = await this.workerManager.filterByDateRange(
                    stateEntries as any[],
                    startDate.toISOString().split('T')[0],
                    endDate.toISOString().split('T')[0],
                    {
                        includeStatistics: true,
                        onProgress: (progress) => {
                            safeLogger.debug('DateNavigatorIntegration', 'Progress update', progress);
                        }
                    }
                );
                
                safeLogger.debug('DateNavigatorIntegration', 'Worker filtering completed', {
                    visibleResults: result.visibilityMap ? result.visibilityMap.filter(r => r.visible).length : 0,
                    totalResults: result.visibilityMap ? result.visibilityMap.length : 0
                });
                
                // Update time filter manager with processed results
                if (this.timeFilterManager && typeof this.timeFilterManager.setCustomRange === 'function') {
                    safeLogger.info('DateNavigatorIntegration', 'Setting custom range in TimeFilterManager', {
                        startDate: startDate.toISOString().split('T')[0],
                        endDate: endDate.toISOString().split('T')[0],
                        startDateObj: startDate,
                        endDateObj: endDate,
                        timeFilterManagerType: typeof this.timeFilterManager,
                        setCustomRangeExists: typeof this.timeFilterManager.setCustomRange === 'function'
                    });
                    
                    try {
                        // Call setCustomRange and log the result
                        const result = this.timeFilterManager.setCustomRange(startDate, endDate);
                        safeLogger.info('DateNavigatorIntegration', 'TimeFilterManager.setCustomRange result', { result });
                        
                        // Check what the current range is after setting it
                        if (typeof this.timeFilterManager.getCurrentRange === 'function') {
                            const currentRange = this.timeFilterManager.getCurrentRange();
                            safeLogger.info('DateNavigatorIntegration', 'TimeFilterManager current range after setting', {
                                currentRange: currentRange ? {
                                    start: currentRange.start?.toISOString?.()?.split('T')[0] || currentRange.start,
                                    end: currentRange.end?.toISOString?.()?.split('T')[0] || currentRange.end
                                } : null
                            });
                        }
                        
                        // CRITICAL: Manually trigger table updates since we blocked the global function
                        this.triggerTableUpdates(startDate, endDate);
                        
                    } catch (setRangeError) {
                        safeLogger.error('DateNavigatorIntegration', 'Error calling setCustomRange', setRangeError);
                        new Notice('Error setting date range. Please try again.');
                        return;
                    }
                    
                    // Show completion notice with performance info
                    const formatDate = (date: Date) => format(date, 'MMM d, yyyy');
                    const noticeMessage = this.isSameDay(startDate, endDate) 
                        ? `Filtered to ${formatDate(startDate)}`
                        : `Filtered from ${formatDate(startDate)} to ${formatDate(endDate)}`;
                    
                    new Notice(noticeMessage);
                    
                } else {
                    safeLogger.error('DateNavigatorIntegration', 'Cannot set custom range - timeFilterManager is invalid', {
                        hasTimeFilterManager: !!this.timeFilterManager,
                        timeFilterManagerType: typeof this.timeFilterManager,
                        hasSetCustomRange: this.timeFilterManager ? typeof this.timeFilterManager.setCustomRange === 'function' : false
                    });
                    new Notice('Filter could not be applied. Please try again.');
                }
                
            } catch (error) {
                this.handleFilterError(error);
            }
            
        } catch (error) {
            this.handleFilterError(error);
        } finally {
            this.hideProgressIndicator();
            this.isUpdatingSelection = false;
            this.isProcessing = false;
        }
    }
    
    /**
     * Phase 2: Worker-enhanced filter clearing
     */
    private async clearDateFilter(): Promise<void> {
        // Prevent recursive updates
        if (this.isUpdatingSelection || this.isProcessing) return;
        
        this.isUpdatingSelection = true;
        this.isProcessing = true;
        
        try {
            // Clear filter in TimeFilterManager
            if (this.timeFilterManager && typeof this.timeFilterManager.clearCurrentFilter === 'function') {
                this.timeFilterManager.clearCurrentFilter();
                new Notice('Date filter cleared');
                
                safeLogger.debug('DateNavigatorIntegration', 'Date filter cleared successfully');
            } else {
                safeLogger.error('DateNavigatorIntegration', 'Cannot clear filter - timeFilterManager is invalid');
                new Notice('Filter could not be cleared. Please try again.');
            }
            
        } catch (error) {
            this.handleFilterError(error);
        } finally {
            this.isUpdatingSelection = false;
            this.isProcessing = false;
        }
    }
    
    /**
     * Handle date selection during range selection mode
     */
    private async handleRangeSelection(selectedDate: Date | null): Promise<void> {
        if (!selectedDate) return;
        
        // If no start date is selected yet, set it
        if (!this.rangeStartDate) {
            this.rangeStartDate = new Date(selectedDate);
            
            safeLogger.info('DateNavigatorIntegration', 'Range start date selected', { 
                date: this.rangeStartDate.toISOString().split('T')[0] 
            });
            
            // Show notice
            new Notice(`Range start: ${format(this.rangeStartDate, 'MMM d, yyyy')} - Now select end date`);
            
            // Visual indication: Highlight the start date with special styling
            this.highlightRangeStart(this.rangeStartDate);
            
            return;
        }
        
        // If we already have a start date, use the selected date as the end date
        this.rangeEndDate = new Date(selectedDate);
        
        safeLogger.info('DateNavigatorIntegration', 'Range end date selected', { 
            start: this.rangeStartDate.toISOString().split('T')[0], 
            end: this.rangeEndDate.toISOString().split('T')[0]
        });
        
        // Ensure start date is before end date
        let start = this.rangeStartDate;
        let end = this.rangeEndDate;
        
        if (start > end) {
            // Swap dates if needed
            [start, end] = [end, start];
        }
        
        // Visual indication: Highlight the entire range
        this.highlightDateRange(start, end);
        
        // Show notice about the range selection
        const formatDate = (date: Date) => format(date, 'MMM d, yyyy');
        new Notice(`ðŸ“… Range selected: ${formatDate(start)} to ${formatDate(end)}. Click Apply Filter to apply.`, 4000);
        
        // Store the completed range for Apply Filter button
        this.completedRange = { start, end };
        
        safeLogger.info('DateNavigatorIntegration', 'Range selection completed', {
            startDate: start.toISOString().split('T')[0],
            endDate: end.toISOString().split('T')[0],
            startDateFull: start.toISOString(),
            endDateFull: end.toISOString(),
            startTime: start.getTime(),
            endTime: end.getTime(),
            completedRangeStored: {
                start: this.completedRange.start.toISOString(),
                end: this.completedRange.end.toISOString()
            }
        });
    }
    
    /**
     * Highlight the range start date with special styling
     */
    private highlightRangeStart(startDate: Date): void {
        if (!this.dateNavigator || !this.container) return;
        
        try {
            // Clear any existing range highlights
            this.clearRangeHighlights();
            
            // Get the day element for the start date
            const dayElement = this.findDayElement(startDate);
            if (dayElement) {
                dayElement.classList.add('oom-range-start');
                dayElement.style.cssText += `
                    background: linear-gradient(135deg, var(--interactive-accent), var(--interactive-accent-hover)) !important;
                    color: var(--text-on-accent) !important;
                    border: 2px solid var(--interactive-accent) !important;
                    border-radius: 6px !important;
                    position: relative !important;
                `;
                
                // Add a visual indicator
                const indicator = document.createElement('div');
                indicator.className = 'oom-range-indicator';
                indicator.textContent = 'START';
                indicator.style.cssText = `
                    position: absolute;
                    top: -8px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: var(--interactive-accent);
                    color: var(--text-on-accent);
                    font-size: 8px;
                    padding: 1px 4px;
                    border-radius: 3px;
                    font-weight: bold;
                    z-index: 10;
                `;
                dayElement.appendChild(indicator);
                
                safeLogger.debug('DateNavigatorIntegration', 'Range start highlighted', {
                    date: startDate.toISOString().split('T')[0]
                });
            }
        } catch (error) {
            safeLogger.error('DateNavigatorIntegration', 'Failed to highlight range start', error);
        }
    }
    
    /**
     * Highlight the entire date range with visual indication
     */
    private highlightDateRange(startDate: Date, endDate: Date): void {
        if (!this.dateNavigator || !this.container) return;
        
        try {
            // Clear any existing range highlights
            this.clearRangeHighlights();
            
            // Get all dates in the range
            const dates = this.getDateRange(startDate, endDate);
            
            dates.forEach((date, index) => {
                const dayElement = this.findDayElement(date);
                if (dayElement) {
                    const isStart = index === 0;
                    const isEnd = index === dates.length - 1;
                    const isMiddle = !isStart && !isEnd;
                    
                    // Apply appropriate styling based on position in range
                    if (isStart) {
                        dayElement.classList.add('oom-range-start');
                        dayElement.style.cssText += `
                            background: linear-gradient(135deg, var(--interactive-accent), var(--interactive-accent-hover)) !important;
                            color: var(--text-on-accent) !important;
                            border: 2px solid var(--interactive-accent) !important;
                            border-radius: 6px 0 0 6px !important;
                            position: relative !important;
                        `;
                        
                        // Add START indicator
                        const indicator = document.createElement('div');
                        indicator.className = 'oom-range-indicator';
                        indicator.textContent = 'START';
                        indicator.style.cssText = `
                            position: absolute;
                            top: -8px;
                            left: 50%;
                            transform: translateX(-50%);
                            background: var(--interactive-accent);
                            color: var(--text-on-accent);
                            font-size: 8px;
                            padding: 1px 4px;
                            border-radius: 3px;
                            font-weight: bold;
                            z-index: 10;
                        `;
                        dayElement.appendChild(indicator);
                    } else if (isEnd) {
                        dayElement.classList.add('oom-range-end');
                        dayElement.style.cssText += `
                            background: linear-gradient(135deg, var(--interactive-accent), var(--interactive-accent-hover)) !important;
                            color: var(--text-on-accent) !important;
                            border: 2px solid var(--interactive-accent) !important;
                            border-radius: 0 6px 6px 0 !important;
                            position: relative !important;
                        `;
                        
                        // Add END indicator
                        const indicator = document.createElement('div');
                        indicator.className = 'oom-range-indicator';
                        indicator.textContent = 'END';
                        indicator.style.cssText = `
                            position: absolute;
                            top: -8px;
                            left: 50%;
                            transform: translateX(-50%);
                            background: var(--interactive-accent);
                            color: var(--text-on-accent);
                            font-size: 8px;
                            padding: 1px 4px;
                            border-radius: 3px;
                            font-weight: bold;
                            z-index: 10;
                        `;
                        dayElement.appendChild(indicator);
                    } else if (isMiddle) {
                        dayElement.classList.add('oom-range-middle');
                        dayElement.style.cssText += `
                            background: linear-gradient(90deg, rgba(var(--interactive-accent-rgb), 0.3), rgba(var(--interactive-accent-rgb), 0.5)) !important;
                            color: var(--text-normal) !important;
                            border-top: 2px solid var(--interactive-accent) !important;
                            border-bottom: 2px solid var(--interactive-accent) !important;
                            position: relative !important;
                        `;
                    }
                });
            });
            
            safeLogger.info('DateNavigatorIntegration', 'Date range highlighted', {
                startDate: startDate.toISOString().split('T')[0],
                endDate: endDate.toISOString().split('T')[0],
                daysInRange: dates.length
            });
            
        } catch (error) {
            safeLogger.error('DateNavigatorIntegration', 'Failed to highlight date range', error);
        }
    }
}