/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DreamMetricsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// types.ts
var DEFAULT_METRICS = [
  {
    name: "Sensory Detail",
    range: { min: 1, max: 5 },
    description: "Level of sensory information recalled from the dream"
  },
  {
    name: "Emotional Recall",
    range: { min: 1, max: 5 },
    description: "Level of emotional detail recalled from the dream"
  },
  {
    name: "Lost Segments",
    range: { min: 0, max: 10 },
    description: "Number of distinct instances where parts of the dream are missing or forgotten"
  },
  {
    name: "Descriptiveness",
    range: { min: 1, max: 5 },
    description: "Level of detail in the dream description"
  },
  {
    name: "Confidence Score",
    range: { min: 1, max: 5 },
    description: "Confidence level in the completeness of dream recall"
  }
];

// settings.ts
var import_obsidian = require("obsidian");
function validateMetricName(name, existingMetrics) {
  if (!name.trim())
    return "Name cannot be empty";
  if (name.length > 50)
    return "Name must be 50 characters or less";
  if (!/^[a-zA-Z0-9\s-]+$/.test(name))
    return "Name can only contain letters, numbers, spaces, and hyphens";
  if (existingMetrics.some((m) => m.name.toLowerCase() === name.toLowerCase())) {
    return "A metric with this name already exists";
  }
  return null;
}
function validateMetricRange(min, max) {
  if (min < 0 || max < 0)
    return "Range values cannot be negative";
  if (min > max)
    return "Minimum value must be less than maximum value";
  if (max > 100)
    return "Maximum value cannot exceed 100";
  if (!Number.isInteger(min) || !Number.isInteger(max))
    return "Range values must be integers";
  return null;
}
function validateMetricDescription(description) {
  if (!description.trim())
    return "Description cannot be empty";
  if (description.length > 200)
    return "Description must be 200 characters or less";
  return null;
}
var MetricEditorModal = class extends import_obsidian.Modal {
  constructor(app, metric, existingMetrics, onSubmit, isEditing = false) {
    super(app);
    this.metric = { ...metric };
    this.existingMetrics = existingMetrics;
    this.onSubmit = onSubmit;
    this.isEditing = isEditing;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("oom-metric-editor-modal");
    contentEl.createEl("h2", { text: this.isEditing ? "Edit Metric" : "Add New Metric" });
    const nameSetting = new import_obsidian.Setting(contentEl).setName("Name").setDesc("The name of the metric (letters, numbers, spaces, and hyphens only)").addText((text) => {
      text.setValue(this.metric.name).onChange((value) => {
        const error = validateMetricName(value, this.existingMetrics);
        nameSetting.setDesc(error || "The name of the metric (letters, numbers, spaces, and hyphens only)");
        nameSetting.controlEl.classList.toggle("is-invalid", !!error);
        this.metric.name = value;
        this.updatePreview();
      });
    });
    const rangeSetting = new import_obsidian.Setting(contentEl).setName("Range").setDesc("The valid range for this metric").addText((text) => {
      text.setValue(this.metric.range.min.toString()).setPlaceholder("Min").onChange((value) => {
        const min = parseInt(value);
        const error = validateMetricRange(min, this.metric.range.max);
        rangeSetting.setDesc(error || "The valid range for this metric");
        rangeSetting.controlEl.classList.toggle("is-invalid", !!error);
        if (!isNaN(min))
          this.metric.range.min = min;
        this.updatePreview();
      });
    }).addText((text) => {
      text.setValue(this.metric.range.max.toString()).setPlaceholder("Max").onChange((value) => {
        const max = parseInt(value);
        const error = validateMetricRange(this.metric.range.min, max);
        rangeSetting.setDesc(error || "The valid range for this metric");
        rangeSetting.controlEl.classList.toggle("is-invalid", !!error);
        if (!isNaN(max))
          this.metric.range.max = max;
        this.updatePreview();
      });
    });
    const descSetting = new import_obsidian.Setting(contentEl).setName("Description").setDesc("A description of what this metric measures").addTextArea((text) => {
      text.setValue(this.metric.description).onChange((value) => {
        const error = validateMetricDescription(value);
        descSetting.setDesc(error || "A description of what this metric measures");
        descSetting.controlEl.classList.toggle("is-invalid", !!error);
        this.metric.description = value;
      });
    });
    const previewSetting = new import_obsidian.Setting(contentEl).setName("Preview").setDesc("How this metric will appear in your dream journal:");
    const previewEl = contentEl.createEl("div", { cls: "oom-metric-preview" });
    this.updatePreview(previewEl);
    const shortcutsEl = contentEl.createEl("div", { cls: "oom-keyboard-shortcuts" });
    shortcutsEl.createEl("div", { text: "Keyboard Shortcuts:" });
    shortcutsEl.createEl("div", { text: "\u2022 Enter: Save changes" });
    shortcutsEl.createEl("div", { text: "\u2022 Esc: Cancel" });
    shortcutsEl.createEl("div", { text: "\u2022 Tab: Next field" });
    shortcutsEl.createEl("div", { text: "\u2022 Shift+Tab: Previous field" });
    const buttonContainer = contentEl.createEl("div", { cls: "oom-metric-editor-buttons" });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => this.close());
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText(this.isEditing ? "Save Changes" : "Add Metric").setCta().onClick(() => {
      if (this.validateAll()) {
        this.onSubmit(this.metric);
        this.close();
      }
    });
    const nameInput = nameSetting.controlEl.querySelector("input");
    if (nameInput)
      nameInput.focus();
  }
  updatePreview(previewEl) {
    if (!previewEl) {
      const el = this.contentEl.querySelector(".oom-metric-preview");
      if (!el)
        return;
      previewEl = el;
    }
    previewEl.empty();
    previewEl.createEl("div", { text: `> [!dream-metrics]` });
    const sampleValue = Math.floor((this.metric.range.min + this.metric.range.max) / 2);
    previewEl.createEl("div", { text: `> ${this.metric.name}: ${sampleValue}` });
    previewEl.createEl("div", {
      cls: "oom-preview-range",
      text: `Valid range: ${this.metric.range.min} to ${this.metric.range.max}`
    });
  }
  validateAll() {
    const nameError = validateMetricName(this.metric.name, this.existingMetrics);
    const rangeError = validateMetricRange(this.metric.range.min, this.metric.range.max);
    const descError = validateMetricDescription(this.metric.description);
    if (nameError || rangeError || descError) {
      new import_obsidian.Notice("Please fix all validation errors before saving");
      return false;
    }
    return true;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var DreamMetricsSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Dream Metrics Settings" });
    containerEl.createEl("h3", { text: "Backup Settings" });
    new import_obsidian.Setting(containerEl).setName("Enable Backups").setDesc("Create backups of the project note before making changes").addToggle((toggle) => toggle.setValue(this.plugin.settings.backupEnabled).onChange(async (value) => {
      this.plugin.settings.backupEnabled = value;
      await this.plugin.saveSettings();
    }));
    const backupFolderSetting = new import_obsidian.Setting(containerEl).setName("Backup Folder").setDesc("Select an existing folder where backups will be stored").addSearch((search) => {
      search.setPlaceholder("Choose backup folder...").setValue(this.plugin.settings.backupFolderPath);
      const parentForSuggestions = search.inputEl.parentElement || containerEl;
      const suggestionContainer2 = parentForSuggestions.createEl("div", {
        cls: "suggestion-container oom-suggestion-container",
        attr: {
          style: `
                            display: none;
                            position: absolute;
                            z-index: 1000;
                            background: var(--background-primary);
                            border: 1px solid var(--background-modifier-border);
                            border-radius: 4px;
                            max-height: 200px;
                            overflow-y: auto;
                            min-width: 180px;
                            width: 100%;
                            box-shadow: 0 2px 8px var(--background-modifier-box-shadow);
                        `
        }
      });
      function positionSuggestionContainer() {
        const inputRect = search.inputEl.getBoundingClientRect();
        const parent = search.inputEl.parentElement || containerEl;
        const parentRect = parent.getBoundingClientRect();
        const dropdownWidth = Math.max(inputRect.width, 180);
        let left = inputRect.left - parentRect.left;
        let top = inputRect.bottom - parentRect.top;
        suggestionContainer2.style.position = "absolute";
        suggestionContainer2.style.left = `${left}px`;
        suggestionContainer2.style.top = `${top}px`;
        suggestionContainer2.style.width = `${dropdownWidth}px`;
        suggestionContainer2.style.overflowX = "auto";
      }
      this.plugin.register(() => suggestionContainer2.remove());
      const getFolders = () => {
        const folders = [];
        const files = this.app.vault.getAllLoadedFiles();
        files.forEach((file) => {
          if (file instanceof import_obsidian.TFolder) {
            folders.push(file.path);
          }
        });
        return folders.sort((a, b) => a.localeCompare(b));
      };
      const showSuggestions2 = (query) => {
        const folders = getFolders();
        const normalizedQuery = query.toLowerCase();
        const filteredFolders = folders.filter((folder) => folder.toLowerCase().includes(normalizedQuery)).slice(0, 10);
        console.log("[Backup Folder] all folders:", folders);
        console.log("[Backup Folder] filtered folders:", filteredFolders);
        suggestionContainer2.empty();
        if (filteredFolders.length > 0) {
          filteredFolders.forEach((folder) => {
            const item = suggestionContainer2.createEl("div", {
              cls: "suggestion-item",
              attr: {
                style: "padding: 8px 12px; cursor: pointer; border-bottom: 1px solid var(--background-modifier-border); background: var(--background-primary);"
              }
            });
            item.textContent = folder;
            item.addEventListener("mouseenter", () => {
              item.style.backgroundColor = "var(--background-modifier-hover)";
            });
            item.addEventListener("mouseleave", () => {
              item.style.backgroundColor = "var(--background-primary)";
            });
            item.addEventListener("mousedown", async (e) => {
              e.preventDefault();
              search.setValue(folder);
              this.plugin.settings.backupFolderPath = folder;
              await this.plugin.saveSettings();
              suggestionContainer2.style.display = "none";
            });
          });
          positionSuggestionContainer();
          suggestionContainer2.style.display = "block";
        } else {
          suggestionContainer2.style.display = "none";
        }
      };
      search.inputEl.addEventListener("keydown", (e) => {
        var _a, _b;
        const items = suggestionContainer2.querySelectorAll(".suggestion-item");
        const currentIndex = Array.from(items).findIndex(
          (item) => item.classList.contains("is-selected")
        );
        switch (e.key) {
          case "ArrowDown":
            e.preventDefault();
            if (currentIndex < items.length - 1) {
              (_a = items[currentIndex]) == null ? void 0 : _a.classList.remove("is-selected");
              items[currentIndex + 1].classList.add("is-selected");
              items[currentIndex + 1].scrollIntoView({ block: "nearest" });
            }
            break;
          case "ArrowUp":
            e.preventDefault();
            if (currentIndex > 0) {
              (_b = items[currentIndex]) == null ? void 0 : _b.classList.remove("is-selected");
              items[currentIndex - 1].classList.add("is-selected");
              items[currentIndex - 1].scrollIntoView({ block: "nearest" });
            }
            break;
          case "Enter":
            e.preventDefault();
            const selectedItem = suggestionContainer2.querySelector(".is-selected");
            if (selectedItem) {
              const folder = selectedItem.textContent;
              if (folder) {
                search.setValue(folder);
                this.plugin.settings.backupFolderPath = folder;
                this.plugin.saveSettings();
                suggestionContainer2.style.display = "none";
              }
            }
            break;
          case "Escape":
            suggestionContainer2.style.display = "none";
            break;
        }
      });
      search.inputEl.addEventListener("blur", () => {
        setTimeout(() => {
          suggestionContainer2.style.display = "none";
        }, 200);
      });
      search.inputEl.addEventListener("input", (e) => {
        console.log("[Backup Folder] input event:", search.inputEl.value);
        showSuggestions2(search.inputEl.value);
      });
      window.addEventListener("resize", () => {
        if (suggestionContainer2.style.display !== "none") {
          positionSuggestionContainer();
        }
      });
    });
    new import_obsidian.Setting(containerEl).setName("Project Note Path").setDesc("The path where metrics tables will be written").addText((text) => {
      text.setPlaceholder("Journals/Dream Diary/Metrics/Metrics.md").setValue(this.plugin.settings.projectNotePath).onChange(async (value) => {
        this.plugin.settings.projectNotePath = value;
        await this.plugin.saveSettings();
      });
      const inputEl = text.inputEl;
      inputEl.addClass("oom-file-suggestion");
      const suggestionContainer2 = containerEl.createEl("div", {
        cls: "suggestion-container oom-suggestion-container"
      });
      function positionSuggestionContainer() {
        const inputRect = inputEl.getBoundingClientRect();
        const modalEl = containerEl.closest(".modal");
        const modalRect = modalEl ? modalEl.getBoundingClientRect() : containerEl.getBoundingClientRect();
        const dropdownWidth = Math.max(inputRect.width, 180);
        let left = inputRect.left - modalRect.left;
        let top = inputRect.bottom - modalRect.top;
        let maxWidth = modalRect.width;
        suggestionContainer2.style.position = "absolute";
        suggestionContainer2.style.left = `${left}px`;
        suggestionContainer2.style.right = "";
        suggestionContainer2.style.maxWidth = `${maxWidth}px`;
        if (left + dropdownWidth > modalRect.width) {
          suggestionContainer2.style.left = "auto";
          suggestionContainer2.style.right = "0";
        }
        suggestionContainer2.style.top = `${top}px`;
        suggestionContainer2.style.width = `${dropdownWidth}px`;
        suggestionContainer2.style.overflowX = "auto";
      }
      function normalize(str) {
        return str.toLowerCase().replace(/\s+/g, "");
      }
      function hideSuggestions2() {
        suggestionContainer2.style.display = "none";
        suggestionContainer2.empty();
      }
      function generateYearPaths(year) {
        const basePaths = [
          "Journals",
          "Dreams",
          "Journal",
          "Dream Diary"
        ];
        return basePaths.flatMap((base) => [
          `${base}/${year}/${year}.md`,
          `${base}/${year}/`,
          `${base}/${year}/Entries/`,
          `${base}/${year}/Dreams/`
        ]);
      }
      function filterFiles(files, searchValue) {
        const normalizedSearch = normalize(searchValue);
        const yearMatch = searchValue.match(/^(20\d{2})$/);
        let suggestions = [];
        if (yearMatch) {
          suggestions.push(...generateYearPaths(yearMatch[1]));
        }
        const matchingFiles = files.filter((file) => {
          if (file.path.includes(".backup-") || file.path.includes("/Backups/") || file.basename.endsWith(".backup")) {
            return false;
          }
          const normalizedPath = normalize(file.path);
          return normalizedPath.includes(normalizedSearch) || yearMatch && file.path.includes(yearMatch[1]);
        }).map((file) => file.path);
        suggestions.push(...matchingFiles);
        suggestions = [...new Set(suggestions)].sort((a, b) => {
          const aExact = a.toLowerCase() === searchValue.toLowerCase();
          const bExact = b.toLowerCase() === searchValue.toLowerCase();
          if (aExact && !bExact)
            return -1;
          if (!aExact && bExact)
            return 1;
          const aYear = a.includes(`/${searchValue}/`);
          const bYear = b.includes(`/${searchValue}/`);
          if (aYear && !bYear)
            return -1;
          if (!aYear && bYear)
            return 1;
          return a.localeCompare(b);
        }).slice(0, 7);
        return suggestions;
      }
      async function updateSuggestions() {
        const value = inputEl.value.trim();
        if (!value) {
          hideSuggestions2();
          return;
        }
        const files = this.app.vault.getMarkdownFiles();
        const suggestions = filterFiles(files, value);
        if (suggestions.length > 0) {
          suggestionContainer2.empty();
          suggestions.forEach((suggestion) => {
            const item = suggestionContainer2.createEl("div", {
              cls: "suggestion-item",
              attr: {
                style: "padding: 8px 12px; cursor: pointer; border-bottom: 1px solid var(--background-modifier-border);"
              }
            });
            const regex = new RegExp(`(${value})`, "gi");
            item.innerHTML = suggestion.replace(regex, "<strong>$1</strong>");
            item.addEventListener("mouseover", () => {
              item.style.backgroundColor = "var(--background-modifier-hover)";
            });
            item.addEventListener("mouseout", () => {
              item.style.backgroundColor = "";
            });
            item.addEventListener("click", async () => {
              inputEl.value = suggestion;
              this.plugin.settings.projectNotePath = suggestion;
              await this.plugin.saveSettings();
              hideSuggestions2();
            });
          });
          suggestionContainer2.style.display = "block";
          positionSuggestionContainer();
        } else {
          hideSuggestions2();
        }
      }
      inputEl.addEventListener("input", updateSuggestions.bind(this));
      inputEl.addEventListener("blur", () => {
        setTimeout(hideSuggestions2, 200);
      });
      inputEl.addEventListener("keydown", (e) => {
        var _a, _b;
        const items = suggestionContainer2.querySelectorAll(".suggestion-item");
        const currentIndex = Array.from(items).findIndex(
          (item) => item.classList.contains("is-selected")
        );
        switch (e.key) {
          case "ArrowDown":
            e.preventDefault();
            if (currentIndex < items.length - 1) {
              (_a = items[currentIndex]) == null ? void 0 : _a.classList.remove("is-selected");
              items[currentIndex + 1].classList.add("is-selected");
              items[currentIndex + 1].scrollIntoView({ block: "nearest" });
            }
            break;
          case "ArrowUp":
            e.preventDefault();
            if (currentIndex > 0) {
              (_b = items[currentIndex]) == null ? void 0 : _b.classList.remove("is-selected");
              items[currentIndex - 1].classList.add("is-selected");
              items[currentIndex - 1].scrollIntoView({ block: "nearest" });
            }
            break;
          case "Enter":
            e.preventDefault();
            const selectedItem = suggestionContainer2.querySelector(".is-selected");
            if (selectedItem) {
              const path = selectedItem.textContent;
              if (path) {
                inputEl.value = path;
                this.plugin.settings.projectNotePath = path;
                this.plugin.saveSettings();
                hideSuggestions2();
              }
            }
            break;
          case "Escape":
            hideSuggestions2();
            break;
        }
      });
      document.addEventListener("click", (e) => {
        if (!inputEl.contains(e.target) && !suggestionContainer2.contains(e.target)) {
          hideSuggestions2();
        }
      });
    });
    new import_obsidian.Setting(containerEl).setName("Callout Name").setDesc('Name of the callout block used for dream metrics (e.g., "dream-metrics")').addText((text) => text.setPlaceholder("dream-metrics").setValue(this.plugin.settings.calloutName).onChange(async (value) => {
      this.plugin.settings.calloutName = value.toLowerCase().replace(/\s+/g, "-");
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Selected Notes").setDesc("Notes to search for dream metrics (select one or more)").addExtraButton((button) => {
    });
    const selectedNotesContainer = containerEl.createEl("div", { cls: "oom-multiselect-container" });
    const chipsContainer = selectedNotesContainer.createEl("div", { cls: "oom-chips-container" });
    const input = selectedNotesContainer.createEl("input", {
      type: "text",
      cls: "oom-multiselect-input",
      attr: { placeholder: "Type to search notes..." }
    });
    const suggestionContainer = selectedNotesContainer.createEl("div", {
      cls: "suggestion-container oom-suggestion-container",
      attr: { style: "display: none; position: absolute; z-index: 1000; background: var(--background-primary); border: 1px solid var(--background-modifier-border); border-radius: 4px; max-height: 200px; overflow-y: auto; min-width: 180px; width: 100%; box-shadow: 0 2px 8px var(--background-modifier-box-shadow);" }
    });
    function hideSuggestions() {
      suggestionContainer.style.display = "none";
      suggestionContainer.empty();
    }
    function showSuggestions() {
      if (suggestionContainer.children.length > 0) {
        suggestionContainer.style.display = "block";
        const inputRect = input.getBoundingClientRect();
        const containerRect = selectedNotesContainer.getBoundingClientRect();
        suggestionContainer.style.top = `${inputRect.bottom - containerRect.top}px`;
        suggestionContainer.style.left = "0";
        suggestionContainer.style.width = `${inputRect.width}px`;
      }
    }
    function renderChips() {
      chipsContainer.empty();
      for (const note of this.plugin.settings.selectedNotes) {
        const chip = chipsContainer.createEl("span", { cls: "oom-chip" });
        const chipText = chip.createEl("span", { cls: "oom-chip-text", text: note });
        chipText.setAttr("title", note);
        const removeBtn = chip.createEl("span", { cls: "oom-chip-remove", text: "\xD7" });
        removeBtn.onclick = () => {
          this.plugin.settings.selectedNotes = this.plugin.settings.selectedNotes.filter((n) => n !== note);
          this.plugin.saveSettings();
          renderChips.call(this);
        };
      }
    }
    renderChips.call(this);
    input.addEventListener("input", async (e) => {
      const value = input.value;
      if (!value) {
        hideSuggestions();
        return;
      }
      const files = this.app.vault.getMarkdownFiles();
      const lowerInput = value.toLowerCase();
      const yearMatch = value.match(/^(20\d{2})$/);
      let matchingFiles = files.map((file) => file.path).filter((path) => {
        if (path.includes(".backup-") || path.includes("/Backups/") || path.endsWith(".backup")) {
          return false;
        }
        const lowerPath = path.toLowerCase();
        return !this.plugin.settings.selectedNotes.includes(path) && (lowerPath.includes(lowerInput) || yearMatch && path.includes(yearMatch[1]));
      });
      if (yearMatch) {
        const yearFile = `Journals/${yearMatch[1]}/${yearMatch[1]}.md`;
        if (matchingFiles.includes(yearFile)) {
          matchingFiles = [yearFile, ...matchingFiles.filter((f) => f !== yearFile)];
        }
      }
      matchingFiles = [...new Set(matchingFiles)].sort((a, b) => {
        const aExact = a.toLowerCase() === lowerInput;
        const bExact = b.toLowerCase() === lowerInput;
        if (aExact && !bExact)
          return -1;
        if (!aExact && bExact)
          return 1;
        return a.localeCompare(b);
      }).slice(0, 7);
      suggestionContainer.empty();
      if (matchingFiles.length > 0) {
        for (const suggestion of matchingFiles) {
          const item = suggestionContainer.createEl("div", {
            cls: "suggestion-item",
            attr: {
              title: suggestion,
              style: "padding: 8px 12px; cursor: pointer; border-bottom: 1px solid var(--background-modifier-border); background: var(--background-primary);"
            }
          });
          item.textContent = suggestion;
          item.addEventListener("mouseenter", () => {
            item.style.backgroundColor = "var(--background-modifier-hover)";
          });
          item.addEventListener("mouseleave", () => {
            item.style.backgroundColor = "var(--background-primary)";
          });
          item.onclick = () => {
            this.plugin.settings.selectedNotes.push(suggestion);
            this.plugin.saveSettings();
            input.value = "";
            hideSuggestions();
            renderChips.call(this);
          };
        }
        showSuggestions();
      } else {
        hideSuggestions();
      }
    });
    document.addEventListener("click", (e) => {
      if (!selectedNotesContainer.contains(e.target)) {
        hideSuggestions();
      }
    });
    input.addEventListener("keydown", (e) => {
      var _a, _b;
      const items = suggestionContainer.querySelectorAll(".suggestion-item");
      const currentIndex = Array.from(items).findIndex((item) => item.classList.contains("is-selected"));
      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          if (currentIndex < items.length - 1) {
            (_a = items[currentIndex]) == null ? void 0 : _a.classList.remove("is-selected");
            items[currentIndex + 1].classList.add("is-selected");
            items[currentIndex + 1].scrollIntoView({ block: "nearest" });
          } else if (items.length > 0 && currentIndex === -1) {
            items[0].classList.add("is-selected");
            items[0].scrollIntoView({ block: "nearest" });
          }
          break;
        case "ArrowUp":
          e.preventDefault();
          if (currentIndex > 0) {
            (_b = items[currentIndex]) == null ? void 0 : _b.classList.remove("is-selected");
            items[currentIndex - 1].classList.add("is-selected");
            items[currentIndex - 1].scrollIntoView({ block: "nearest" });
          }
          break;
        case "Enter":
          e.preventDefault();
          const selectedItem = suggestionContainer.querySelector(".is-selected");
          if (selectedItem) {
            const path = selectedItem.textContent;
            if (path) {
              this.plugin.settings.selectedNotes.push(path);
              this.plugin.saveSettings();
              input.value = "";
              hideSuggestions();
              renderChips.call(this);
            }
          }
          break;
        case "Escape":
          hideSuggestions();
          break;
      }
    });
    containerEl.createEl("h3", { text: "Metrics Configuration" });
    this.plugin.settings.metrics.forEach((metric, index) => {
      const metricSetting = new import_obsidian.Setting(containerEl).setName(metric.name).setDesc(`Range: ${metric.range.min}-${metric.range.max}`).addExtraButton((button) => {
        const handle = button.setIcon("grip-vertical").setTooltip("Drag to reorder").extraSettingsEl;
        handle.addClass("oom-drag-handle");
        handle.setAttribute("draggable", "true");
        handle.addEventListener("dragstart", (e) => {
          if (e.dataTransfer) {
            e.dataTransfer.setData("text/plain", index.toString());
            handle.addClass("is-dragging");
          }
        });
        handle.addEventListener("dragend", () => {
          handle.removeClass("is-dragging");
        });
      });
      const settingEl = metricSetting.settingEl;
      settingEl.setAttribute("data-index", index.toString());
      settingEl.addEventListener("dragover", (e) => {
        e.preventDefault();
        const draggingEl = containerEl.querySelector(".is-dragging");
        if (draggingEl && draggingEl !== settingEl) {
          settingEl.addClass("oom-drop-target");
        }
      });
      settingEl.addEventListener("dragleave", () => {
        settingEl.removeClass("oom-drop-target");
      });
      settingEl.addEventListener("drop", async (e) => {
        var _a;
        e.preventDefault();
        settingEl.removeClass("oom-drop-target");
        const fromIndex = parseInt(((_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain")) || "-1");
        const toIndex = parseInt(settingEl.getAttribute("data-index") || "-1");
        if (fromIndex !== -1 && toIndex !== -1 && fromIndex !== toIndex) {
          const metrics = this.plugin.settings.metrics;
          const [movedMetric] = metrics.splice(fromIndex, 1);
          metrics.splice(toIndex, 0, movedMetric);
          await this.plugin.saveSettings();
          this.display();
        }
      });
      if (index > 0) {
        metricSetting.addExtraButton((button) => button.setIcon("arrow-up").setTooltip("Move up").onClick(async () => {
          const metrics = this.plugin.settings.metrics;
          [metrics[index], metrics[index - 1]] = [metrics[index - 1], metrics[index]];
          await this.plugin.saveSettings();
          this.display();
        }));
      }
      if (index < this.plugin.settings.metrics.length - 1) {
        metricSetting.addExtraButton((button) => button.setIcon("arrow-down").setTooltip("Move down").onClick(async () => {
          const metrics = this.plugin.settings.metrics;
          [metrics[index], metrics[index + 1]] = [metrics[index + 1], metrics[index]];
          await this.plugin.saveSettings();
          this.display();
        }));
      }
      metricSetting.addExtraButton((button) => button.setIcon("pencil").setTooltip("Edit metric").onClick(() => {
        new MetricEditorModal(
          this.app,
          metric,
          this.plugin.settings.metrics,
          async (updatedMetric) => {
            this.plugin.settings.metrics[index] = updatedMetric;
            await this.plugin.saveSettings();
            this.display();
          },
          true
        ).open();
      })).addExtraButton((button) => button.setIcon("trash").setTooltip("Remove metric").onClick(async () => {
        this.plugin.settings.metrics.splice(index, 1);
        await this.plugin.saveSettings();
        this.display();
      }));
    });
    new import_obsidian.Setting(containerEl).setName("Add New Metric").addButton((button) => button.setButtonText("Add Metric").onClick(() => {
      new MetricEditorModal(
        this.app,
        {
          name: "New Metric",
          range: { min: 1, max: 5 },
          description: "Description of the metric"
        },
        this.plugin.settings.metrics,
        async (newMetric) => {
          this.plugin.settings.metrics.push(newMetric);
          await this.plugin.saveSettings();
          this.display();
        }
      ).open();
    }));
    new import_obsidian.Setting(containerEl).setName("Reset to Defaults").setDesc("Restore default metrics while preserving custom metrics").addButton((button) => button.setButtonText("Reset").onClick(async () => {
      const defaultMetricNames = DEFAULT_METRICS.map((m) => m.name.toLowerCase());
      const customMetrics = this.plugin.settings.metrics.filter(
        (m) => !defaultMetricNames.includes(m.name.toLowerCase())
      );
      this.plugin.settings.metrics = [...DEFAULT_METRICS, ...customMetrics];
      await this.plugin.saveSettings();
      this.display();
    }));
  }
};

// main.ts
var DreamMetricsPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new DreamMetricsSettingTab(this.app, this));
    this.addRibbonIcon("lucide-shell", "OneiroMetrics", () => {
      new OneiroMetricsModal(this.app, this).open();
    });
    this.addCommand({
      id: "open-oneirometrics-modal",
      name: "Open OneiroMetrics",
      callback: () => {
        new OneiroMetricsModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "scrape-metrics",
      name: "Scrape Metrics",
      callback: () => this.scrapeMetrics()
    });
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.updateProjectNoteView();
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        if (file && file.path === this.settings.projectNotePath) {
          this.updateProjectNoteView();
        }
      })
    );
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, {
      projectNotePath: "Journals/Dream Diary/Metrics/Metrics.md",
      metrics: [...DEFAULT_METRICS],
      selectedNotes: [],
      calloutName: "dream-metrics",
      backupEnabled: true,
      backupFolderPath: ""
    }, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async scrapeMetrics() {
    const progressModal = new import_obsidian2.Modal(this.app);
    progressModal.titleEl.setText("Scraping Dream Metrics...");
    progressModal.contentEl.createEl("div", { text: "Please wait while metrics are being scraped. This may take a few seconds for large journals." });
    progressModal.open();
    const metrics = {};
    const dreamEntries = [];
    let totalWords = 0;
    let entriesProcessed = 0;
    let calloutsFound = 0;
    let validNotes = 0;
    let foundAnyJournalEntries = false;
    let foundAnyMetrics = false;
    if (!this.settings.selectedNotes || this.settings.selectedNotes.length === 0) {
      new import_obsidian2.Notice("No notes selected. Please select at least one note to scrape.");
      console.warn("[OneiroMetrics] No notes selected.");
      progressModal.close();
      return;
    }
    for (const path of this.settings.selectedNotes) {
      const file = this.app.vault.getAbstractFileByPath(path);
      if (!(file instanceof import_obsidian2.TFile)) {
        console.warn(`[OneiroMetrics] File not found or not a file: ${path}`);
        continue;
      }
      validNotes++;
      try {
        const content = await this.app.vault.read(file);
        console.log(`[OneiroMetrics] Processing file: ${path}`);
        console.log(`[OneiroMetrics] Content length: ${content.length} characters`);
        let journalEntries = content.match(/---\n+> \[!journal-entry\][\s\S]*?\n> \^\d{8}[\s\S]*?(?=\n+---\n+(?:> \[!journal-entry\]|$)|$)/g);
        if (!journalEntries) {
          console.warn(`[OneiroMetrics] No journal entries found in: ${path}`);
          console.log(`[OneiroMetrics] Content preview: ${content.substring(0, 500)}...`);
          continue;
        }
        foundAnyJournalEntries = true;
        console.log(`[OneiroMetrics] Found ${journalEntries.length} journal entries in ${path}`);
        for (const journalEntry of journalEntries) {
          const dateMatch = journalEntry.match(/\^(\d{8})/);
          if (!dateMatch) {
            console.warn(`[OneiroMetrics] Could not extract date from journal entry: ${journalEntry.substring(0, 100)}...`);
            continue;
          }
          const date = dateMatch[1].replace(/(\d{4})(\d{2})(\d{2})/, "$1-$2-$3");
          const entryId = dateMatch[1];
          const dreamDiaries = journalEntry.match(/> \[!dream-diary\].*?\[\[.*?\]\][\s\S]*?(?=\n\n> \[!(?!dream-metrics)|$)/g);
          if (!dreamDiaries) {
            console.log(`[OneiroMetrics] No dream diaries found in journal entry ${date}`);
            continue;
          }
          console.log(`[OneiroMetrics] Found ${dreamDiaries.length} dream diaries in journal entry ${date}`);
          for (const dreamDiary of dreamDiaries) {
            const titleMatch = dreamDiary.match(/> \[!dream-diary\] (.*?) \[\[/);
            if (!titleMatch) {
              console.warn(`[OneiroMetrics] Could not extract title from dream diary: ${dreamDiary.substring(0, 100)}...`);
              continue;
            }
            const title = titleMatch[1].trim();
            const metricsMatch = dreamDiary.match(/> \[!dream-metrics(?:\|.*)?\][\s\S]*?>\s*([\w\W]*?)(?=\n\n> \[!|$)/);
            if (!metricsMatch) {
              console.log(`[OneiroMetrics] No metrics callout found in dream diary: ${title}`);
              continue;
            }
            calloutsFound++;
            foundAnyMetrics = true;
            const metricsText = metricsMatch[1].replace(/>\s*/g, "");
            console.log(`[OneiroMetrics] Found metrics for dream: ${title}`);
            console.log(`[OneiroMetrics] Metrics text: ${metricsText}`);
            const dreamContent = dreamDiary.split(/> \[!dream-metrics\]/)[0].replace(/^> \[!dream-diary\].*?\[\[.*?\]\]\n/m, "").replace(/^>+\s*/gm, "").replace(/\[\[([^\]]+?)\]\]/g, "$1").replace(/!\[.*?\]\(.*?\)/g, "").replace(/\[([^\]]+?)\]\(.*?\)/g, "$1").replace(/```[\s\S]*?```/g, "").replace(/`([^`]+?)`/g, "$1").replace(/\*\*([^*]+?)\*\*/g, "$1").replace(/\*([^*]+?)\*/g, "$1").replace(/<\/?[^>]+(>|$)/g, "").replace(/^---+\s*$/gm, "").replace(/\[!journal-page\|.*?\]/g, "").replace(/![^|\n]+?\|?\d*\s*/g, "").replace(/\n{2,}/g, " ").trim();
            const wordCount = dreamContent.split(/\s+/).length;
            totalWords += wordCount;
            entriesProcessed++;
            const dreamMetrics = {};
            const metricPairs = metricsText.split(",").map((pair) => pair.trim());
            for (const pair of metricPairs) {
              const [name, value] = pair.split(":").map((s) => s.trim());
              if (name && value !== "\u2014" && !isNaN(Number(value))) {
                if (!metrics[name]) {
                  metrics[name] = [];
                }
                const numValue = Number(value);
                metrics[name].push(numValue);
                dreamMetrics[name] = numValue;
              }
            }
            if (!metrics["Words"]) {
              metrics["Words"] = [];
            }
            metrics["Words"].push(wordCount);
            dreamMetrics["Words"] = wordCount;
            dreamEntries.push({
              date,
              title,
              content: dreamContent,
              source: {
                file: path,
                id: entryId
              },
              metrics: dreamMetrics
            });
          }
        }
      } catch (error) {
        console.error(`[OneiroMetrics] Error processing file ${path}:`, error);
        new import_obsidian2.Notice(`Error processing file: ${path}`);
      }
    }
    console.log(`[OneiroMetrics] Notes processed: ${validNotes}`);
    console.log(`[OneiroMetrics] Callouts found: ${calloutsFound}`);
    console.log(`[OneiroMetrics] Entries processed: ${entriesProcessed}`);
    if (validNotes === 0) {
      new import_obsidian2.Notice("No valid notes found. Please check your selected notes.");
      progressModal.close();
      return;
    }
    if (!foundAnyJournalEntries) {
      new import_obsidian2.Notice("No journal entries found in selected notes.");
      progressModal.close();
      return;
    }
    if (!foundAnyMetrics) {
      new import_obsidian2.Notice("No dream metrics callouts found in selected notes.");
      progressModal.close();
      return;
    }
    if (entriesProcessed === 0) {
      new import_obsidian2.Notice("No metrics data found in selected notes.");
      progressModal.close();
      return;
    }
    dreamEntries.sort((a, b) => a.date.localeCompare(b.date));
    await this.updateProjectNote(metrics, dreamEntries);
    progressModal.close();
    new import_obsidian2.Notice("Metrics scraped successfully!");
  }
  async updateProjectNote(metrics, dreamEntries) {
    const projectFile = this.app.vault.getAbstractFileByPath(this.settings.projectNotePath);
    if (!(projectFile instanceof import_obsidian2.TFile)) {
      console.log(`Project note not found: ${this.settings.projectNotePath}`);
      return;
    }
    try {
      const existingContent = await this.app.vault.read(projectFile);
      const tableMatch = existingContent.match(/(.*?)(# OneiroMetrics Analysis.*?)(\n\n.*)/s);
      const beforeTable = tableMatch ? tableMatch[1] : "";
      const afterTable = tableMatch ? tableMatch[3] : "";
      const newContent = beforeTable + this.generateMetricsTable(metrics, dreamEntries) + afterTable;
      if (newContent !== existingContent) {
        await this.backupProjectNote(projectFile);
        const confirmed = await this.confirmOverwrite();
        if (confirmed) {
          await this.app.vault.modify(projectFile, newContent);
          new import_obsidian2.Notice("Metrics tables updated successfully!");
          this.updateProjectNoteView();
        }
      }
    } catch (error) {
      console.error("Error writing to project note:", error);
      new import_obsidian2.Notice("Error updating metrics tables. Check console for details.");
    }
  }
  async backupProjectNote(file) {
    if (!this.settings.backupEnabled) {
      console.log("Backups are disabled in settings");
      return;
    }
    if (!this.settings.backupFolderPath) {
      console.log("No backup folder path set in settings");
      new import_obsidian2.Notice("Please select a backup folder in settings");
      return;
    }
    try {
      const content = await this.app.vault.read(file);
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
      const fileName = file.basename;
      const backupPath = `${this.settings.backupFolderPath}/${fileName}.backup-${timestamp}.md`;
      const backupFolder = this.app.vault.getAbstractFileByPath(this.settings.backupFolderPath);
      if (!backupFolder) {
        try {
          await this.app.vault.createFolder(this.settings.backupFolderPath);
          console.log(`Created backup folder: ${this.settings.backupFolderPath}`);
        } catch (error) {
          console.error("Error creating backup folder:", error);
          new import_obsidian2.Notice(`Error creating backup folder: ${error.message}`);
          return;
        }
      }
      await this.app.vault.create(backupPath, content);
      console.log(`Created backup at: ${backupPath}`);
      new import_obsidian2.Notice(`Backup created: ${backupPath}`);
    } catch (error) {
      console.error("Error creating backup:", error);
      new import_obsidian2.Notice(`Error creating backup: ${error.message}`);
    }
  }
  async confirmOverwrite() {
    return new Promise((resolve) => {
      const modal = new ConfirmModal(
        this.app,
        "Update Metrics Tables",
        "This will overwrite the current metrics tables. A backup will be created before proceeding. Continue?"
      );
      modal.onConfirm = () => {
        resolve(true);
      };
      modal.onCancel = () => {
        resolve(false);
      };
      modal.open();
    });
  }
  generateMetricsTable(metrics, dreamEntries) {
    let content = "";
    content += '<div class="oom-table-section">';
    content += '<div class="oom-table-title">Metrics</div>';
    content += '<div class="oom-table-container">\n';
    content += '<table class="oom-table">\n';
    content += "<thead>\n";
    content += "<tr>\n";
    content += "<th>Metric</th>\n";
    content += "<th>Average</th>\n";
    content += "<th>Min</th>\n";
    content += "<th>Max</th>\n";
    content += "<th>Count</th>\n";
    content += "</tr>\n";
    content += "</thead>\n";
    content += "<tbody>\n";
    const validMetricNames = [
      "Words",
      ...this.settings.metrics.map((m) => m.name)
    ];
    for (const name of validMetricNames) {
      const values = metrics[name];
      if (!values || values.length === 0)
        continue;
      const avg = values.reduce((a, b) => a + b) / values.length;
      const min = Math.min(...values);
      const max = Math.max(...values);
      let label = name;
      if (name === "Words") {
        const total = values.reduce((a, b) => a + b, 0);
        label = `Words <span class="oom-words-total">(total: ${total})</span>`;
      }
      content += "<tr>\n";
      content += `<td>${label}</td>
`;
      content += `<td class="metric-value">${avg.toFixed(2)}</td>
`;
      content += `<td class="metric-value">${min}</td>
`;
      content += `<td class="metric-value">${max}</td>
`;
      content += `<td class="metric-value">${values.length}</td>
`;
      content += "</tr>\n";
    }
    content += "</tbody>\n";
    content += "</table>\n";
    content += "</div>\n";
    content += "</div>\n";
    content += '<div class="oom-table-section">';
    content += '<div class="oom-table-title">Dream Entries</div>';
    content += '<div class="oom-filter-controls">\n';
    content += '<div class="oom-date-filter">\n';
    content += '<label for="dateRange">Date Range:</label>\n';
    content += '<select id="dateRange" class="oom-select">\n';
    content += '<option value="all">All Time</option>\n';
    content += '<option value="month">Last Month</option>\n';
    content += '<option value="week">Last Week</option>\n';
    content += "</select>\n";
    content += "</div>\n";
    content += '<div class="oom-metric-filter">\n';
    content += '<label for="metricFilter">Filter by Metric:</label>\n';
    content += '<select id="metricFilter" class="oom-select">\n';
    content += '<option value="all">All Metrics</option>\n';
    for (const name of this.settings.metrics.map((m) => m.name)) {
      content += `<option value="${name}">${name}</option>
`;
    }
    content += "</select>\n";
    content += "</div>\n";
    content += "</div>\n";
    content += '<div class="oom-table-container">\n';
    content += '<table class="oom-table oom-sortable">\n';
    content += "<thead>\n";
    content += "<tr>\n";
    content += '<th class="oom-sortable" data-sort="date">Date <span class="oom-sort-icon">\u2195</span></th>\n';
    content += '<th class="oom-sortable" data-sort="title">Dream Title <span class="oom-sort-icon">\u2195</span></th>\n';
    content += '<th class="oom-sortable metric-value" data-sort="words">Words <span class="oom-sort-icon">\u2195</span></th>\n';
    content += "<th>Content</th>\n";
    for (const name of this.settings.metrics.map((m) => m.name)) {
      content += `<th class="oom-sortable metric-value" data-sort="${name}">${name} <span class="oom-sort-icon">\u2195</span></th>
`;
    }
    content += "</tr>\n";
    content += "</thead>\n";
    content += "<tbody>\n";
    for (const entry of dreamEntries) {
      content += "<tr>\n";
      content += `<td>${entry.date}</td>
`;
      content += `<td><a href="#^${entry.source.id}" data-href="${entry.source.file}#^${entry.source.id}" class="internal-link">${entry.title}</a></td>
`;
      content += `<td class="metric-value">${entry.metrics["Words"] || 0}</td>
`;
      let dreamContent = entry.content;
      const diaryMatch = dreamContent.match(/> \[!dream-diary\].*?\[\[.*?\]\]\n([\s\S]*?)(?=\n> \[!dream-metrics\]|$)/);
      if (diaryMatch) {
        dreamContent = diaryMatch[1];
        dreamContent = dreamContent.split("\n").map((line) => {
          if (line.match(/\.(?:png|jpg|jpeg|gif)(?:\|\d+)?/i) || line.match(/(?:banister|anister)-journals-\d{8}-.*?(?:\|\d+)?/) || line.match(/^!.*?\|/) || line.match(/^>\s*!.*?\|/) || line.match(/^>\s*\[\[.*?\]\]/) || line.match(/^>\s*\[!.*?\|/) || line.match(/^---+$/)) {
            return "";
          }
          return line;
        }).filter((line) => line.trim() !== "").join("\n");
        dreamContent = dreamContent.replace(/^>+\s*/gm, "").replace(/\[\[([^\]]+?)\]\]/g, "$1").replace(/!\[.*?\]\(.*?\)/g, "").replace(/\[([^\]]+?)\]\(.*?\)/g, "$1").replace(/```[\s\S]*?```/g, "").replace(/`([^`]+?)`/g, "$1").replace(/\*\*([^*]+?)\*\*/g, "$1").replace(/\*([^*]+?)\*/g, "$1").replace(/<\/?[^>]+(>|$)/g, "").replace(/\[!.*?\|.*?\]/g, "").replace(/\n{2,}/g, " ").trim();
        dreamContent = dreamContent.split(" ").filter((word) => {
          return !(word.match(/\.(?:png|jpg|jpeg|gif)(?:\|\d+)?$/i) || word.match(/(?:banister|anister)-journals-\d{8}-.*?(?:\|\d+)?/) || word.match(/^!.*?\|/) || word.match(/\[\[.*?\]\]/) || word.match(/\[!.*?\|.*?\]/));
        }).join(" ").replace(/\s+/g, " ").trim();
      }
      if (!dreamContent || !dreamContent.trim()) {
        dreamContent = "";
      }
      if (dreamContent.length > 200) {
        const preview = dreamContent.substring(0, 200) + "...";
        content += `<td class="oom-dream-content">
                    <input type="checkbox" class="oom-show-toggle" id="oom-toggle-${entry.date}-${entry.title.replace(/[^a-zA-Z0-9]/g, "")}">
                    <div class="oom-content-preview">${preview}</div>
                    <div class="oom-content-full">${dreamContent}</div>
                    <label for="oom-toggle-${entry.date}-${entry.title.replace(/[^a-zA-Z0-9]/g, "")}" class="oom-expand-button oom-show-more">Show more</label>
                    <label for="oom-toggle-${entry.date}-${entry.title.replace(/[^a-zA-Z0-9]/g, "")}" class="oom-expand-button oom-show-less">Show less</label>
                </td>
`;
      } else {
        content += `<td class="oom-dream-content"><div class="oom-content-preview">${dreamContent}</div></td>
`;
      }
      for (const name of this.settings.metrics.map((m) => m.name)) {
        content += `<td class="metric-value">${entry.metrics[name] || ""}</td>
`;
      }
      content += "</tr>\n";
    }
    content += "</tbody>\n";
    content += "</table>\n";
    content += "</div>\n";
    content += "</div>\n";
    return content;
  }
  updateProjectNoteView() {
    var _a;
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (activeView && activeView.file && activeView.file.path === this.settings.projectNotePath) {
      const previewEl = (_a = activeView.previewMode) == null ? void 0 : _a.containerEl;
      if (previewEl) {
        previewEl.setAttribute("data-type", "oom-project-note");
      }
    }
  }
};
var OneiroMetricsModal = class extends import_obsidian2.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("oom-modal");
    contentEl.createEl("h2", { text: "OneiroMetrics" });
    new import_obsidian2.Setting(contentEl).setName("Project Note Path").addSearch((text) => {
      text.setValue(this.plugin.settings.projectNotePath).setPlaceholder("Journals/Dream Diary/Metrics/Metrics.md").onChange((value) => {
        this.plugin.settings.projectNotePath = value;
      });
      const projectNoteInput = text.inputEl;
      projectNoteInput.addClass("oom-file-suggestion");
      projectNoteInput.setAttribute("data-suggestion", "file");
      const projectNoteSuggestionContainer = contentEl.createEl("div", {
        cls: "suggestion-container oom-suggestion-container"
      });
      function positionSuggestionContainer() {
        const inputRect = projectNoteInput.getBoundingClientRect();
        const modalEl = contentEl.closest(".modal");
        const modalRect = modalEl ? modalEl.getBoundingClientRect() : contentEl.getBoundingClientRect();
        const dropdownWidth = Math.max(inputRect.width, 180);
        let left = inputRect.left - modalRect.left;
        let top = inputRect.bottom - modalRect.top;
        let maxWidth = modalRect.width;
        projectNoteSuggestionContainer.style.position = "absolute";
        projectNoteSuggestionContainer.style.left = `${left}px`;
        projectNoteSuggestionContainer.style.right = "";
        projectNoteSuggestionContainer.style.maxWidth = `${maxWidth}px`;
        if (left + dropdownWidth > modalRect.width) {
          projectNoteSuggestionContainer.style.left = "auto";
          projectNoteSuggestionContainer.style.right = "0";
        }
        projectNoteSuggestionContainer.style.top = `${top}px`;
        projectNoteSuggestionContainer.style.width = `${dropdownWidth}px`;
        projectNoteSuggestionContainer.style.overflowX = "auto";
      }
      function normalize(str) {
        return str.toLowerCase().replace(/\s+/g, "");
      }
      projectNoteInput.addEventListener("input", async (e) => {
        const value = projectNoteInput.value;
        if (!value) {
          projectNoteSuggestionContainer.classList.add("oom-hidden");
          return;
        }
        const files = this.app.vault.getMarkdownFiles();
        const lowerInput = value.toLowerCase();
        const yearMatch = value.match(/^(20\d{2})$/);
        let suggestions = [];
        if (yearMatch) {
          const basePaths = [
            "Journals",
            "Dreams",
            "Journal",
            "Dream Diary"
          ];
          suggestions.push(...basePaths.flatMap((base) => [
            `${base}/${yearMatch[1]}/${yearMatch[1]}.md`,
            `${base}/${yearMatch[1]}/`,
            `${base}/${yearMatch[1]}/Entries/`,
            `${base}/${yearMatch[1]}/Dreams/`
          ]));
        }
        const matchingFiles = files.map((file) => file.path).filter((path) => {
          if (path.includes(".backup-") || path.includes("/Backups/") || path.endsWith(".backup")) {
            return false;
          }
          const lowerPath = path.toLowerCase();
          return !this.plugin.settings.selectedNotes.includes(path) && (lowerPath.includes(lowerInput) || yearMatch && path.includes(yearMatch[1]));
        });
        suggestions.push(...matchingFiles);
        suggestions = [...new Set(suggestions)].sort((a, b) => {
          const aExact = a.toLowerCase() === lowerInput;
          const bExact = b.toLowerCase() === lowerInput;
          if (aExact && !bExact)
            return -1;
          if (!aExact && bExact)
            return 1;
          const aYear = a.includes(`/${value}/`);
          const bYear = b.includes(`/${value}/`);
          if (aYear && !bYear)
            return -1;
          if (!aYear && bYear)
            return 1;
          return a.localeCompare(b);
        }).slice(0, 7);
        projectNoteSuggestionContainer.empty();
        if (suggestions.length > 0) {
          for (const suggestion of suggestions) {
            const item = projectNoteSuggestionContainer.createEl("div", {
              cls: "suggestion-item",
              attr: { title: suggestion },
              text: suggestion
            });
            item.onclick = () => {
              this.plugin.settings.projectNotePath = suggestion;
              this.plugin.saveSettings();
              projectNoteInput.value = suggestion;
              projectNoteSuggestionContainer.classList.add("oom-hidden");
            };
          }
          projectNoteSuggestionContainer.classList.remove("oom-hidden");
          positionSuggestionContainer();
        } else {
          projectNoteSuggestionContainer.classList.add("oom-hidden");
        }
      });
      document.addEventListener("click", (e) => {
        if (!projectNoteInput.contains(e.target) && !projectNoteSuggestionContainer.contains(e.target)) {
          projectNoteSuggestionContainer.classList.add("oom-hidden");
        }
      });
    });
    new import_obsidian2.Setting(contentEl).setName("Selected Notes").setDesc("Notes to search for dream metrics (select one or more)").addExtraButton((button) => {
    });
    const selectedNotesContainer = contentEl.createEl("div", { cls: "oom-multiselect-container" });
    const chipsContainer = selectedNotesContainer.createEl("div", { cls: "oom-chips-container" });
    const selectedNotesInput = selectedNotesContainer.createEl("input", {
      type: "text",
      cls: "oom-multiselect-input",
      attr: { placeholder: "Type to search notes..." }
    });
    const selectedNotesSuggestionContainer = selectedNotesContainer.createEl("div", {
      cls: "suggestion-container oom-suggestion-container oom-hidden",
      attr: {
        style: `
                    position: absolute;
                    z-index: 1000;
                    background: var(--background-primary);
                    border: 1px solid var(--background-modifier-border);
                    border-radius: 4px;
                    max-height: 200px;
                    overflow-y: auto;
                    box-shadow: 0 2px 8px var(--background-modifier-box-shadow);
                    width: 100%;
                    top: 100%;
                    left: 0;
                `
      }
    });
    function hideSelectedNotesSuggestions() {
      selectedNotesSuggestionContainer.classList.add("oom-hidden");
    }
    function showSelectedNotesSuggestions() {
      selectedNotesSuggestionContainer.classList.remove("oom-hidden");
      const inputRect = selectedNotesInput.getBoundingClientRect();
      const containerRect = selectedNotesContainer.getBoundingClientRect();
      selectedNotesSuggestionContainer.style.top = `${inputRect.bottom - containerRect.top}px`;
      selectedNotesSuggestionContainer.style.width = `${inputRect.width}px`;
    }
    const renderChips = () => {
      chipsContainer.empty();
      this.plugin.settings.selectedNotes.forEach((note) => {
        const chip = chipsContainer.createEl("div", { cls: "oom-chip" });
        chip.createEl("span", { text: note });
        const removeBtn = chip.createEl("button", { cls: "oom-chip-remove" });
        removeBtn.onclick = () => {
          this.plugin.settings.selectedNotes = this.plugin.settings.selectedNotes.filter((n) => n !== note);
          this.plugin.saveSettings();
          renderChips();
        };
      });
    };
    renderChips();
    selectedNotesInput.addEventListener("input", async (e) => {
      const value = selectedNotesInput.value;
      console.log("[OneiroMetrics][Modal] Input event fired. Value:", value);
      console.log("[OneiroMetrics][Modal] Current selectedNotes:", this.plugin.settings.selectedNotes);
      if (!value) {
        hideSelectedNotesSuggestions();
        return;
      }
      const files = this.app.vault.getMarkdownFiles();
      console.log("[OneiroMetrics][Modal] Files returned by getMarkdownFiles:", files.map((f) => f.path));
      const lowerInput = value.toLowerCase();
      let suggestions = [];
      const matchingFiles = files.map((file) => file.path).filter((path) => {
        if (path.includes(".backup-") || path.includes("/Backups/") || path.endsWith(".backup")) {
          return false;
        }
        const lowerPath = path.toLowerCase();
        return !this.plugin.settings.selectedNotes.includes(path) && lowerPath.includes(lowerInput);
      });
      suggestions = matchingFiles.sort((a, b) => {
        const aExact = a.toLowerCase() === lowerInput;
        const bExact = b.toLowerCase() === lowerInput;
        if (aExact && !bExact)
          return -1;
        if (!aExact && bExact)
          return 1;
        return a.localeCompare(b);
      }).slice(0, 7);
      console.log("[OneiroMetrics][Modal] Suggestions to display:", suggestions);
      selectedNotesSuggestionContainer.empty();
      if (suggestions.length > 0) {
        console.log("[OneiroMetrics][Modal] Creating suggestion items...");
        for (const suggestion of suggestions) {
          const item = selectedNotesSuggestionContainer.createEl("div", {
            cls: "suggestion-item",
            attr: { title: suggestion },
            text: suggestion
          });
          item.onclick = () => {
            if (!this.plugin.settings.selectedNotes.includes(suggestion)) {
              this.plugin.settings.selectedNotes.push(suggestion);
              this.plugin.saveSettings();
              renderChips();
            }
            selectedNotesInput.value = "";
            hideSelectedNotesSuggestions();
          };
        }
        console.log("[OneiroMetrics][Modal] Showing suggestions container...");
        console.log("[OneiroMetrics][Modal] Container display style:", selectedNotesSuggestionContainer.style.display);
        console.log("[OneiroMetrics][Modal] Container classList:", selectedNotesSuggestionContainer.classList);
        showSelectedNotesSuggestions();
        console.log("[OneiroMetrics][Modal] Container display style after show:", selectedNotesSuggestionContainer.style.display);
        console.log("[OneiroMetrics][Modal] Container classList after show:", selectedNotesSuggestionContainer.classList);
      } else {
        console.log("[OneiroMetrics][Modal] No suggestions to display");
        hideSelectedNotesSuggestions();
      }
    });
    document.addEventListener("click", (e) => {
      if (!selectedNotesInput.contains(e.target) && !selectedNotesSuggestionContainer.contains(e.target)) {
        hideSelectedNotesSuggestions();
      }
    });
    new import_obsidian2.Setting(contentEl).setName("Callout Name").addText((text) => text.setValue(this.plugin.settings.calloutName).onChange((value) => {
      this.plugin.settings.calloutName = value.toLowerCase().replace(/\s+/g, "-");
    }));
    new import_obsidian2.Setting(contentEl).setName("Scrape Metrics").addButton((button) => button.setButtonText("Scrape").onClick(async () => {
      await this.plugin.scrapeMetrics();
      new import_obsidian2.Notice("Metrics scraped successfully!");
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ConfirmModal = class extends import_obsidian2.Modal {
  constructor(app, title, message) {
    super(app);
    this.title = title;
    this.message = message;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("oom-confirm-modal");
    contentEl.createEl("h2", { text: this.title });
    contentEl.createEl("p", { text: this.message });
    const buttonContainer = contentEl.createEl("div", { cls: "oom-modal-buttons" });
    new import_obsidian2.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => {
      this.onCancel();
      this.close();
    });
    new import_obsidian2.ButtonComponent(buttonContainer).setButtonText("Continue").setCta().onClick(() => {
      this.onConfirm();
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
